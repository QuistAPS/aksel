//! Scale types for mapping data values to normalized ranges.
//!
//! This module provides the [`Scale`] trait and implementations for different
//! types of scales used in data visualization.
//!
//! # Overview
//!
//! Scales are the fundamental building blocks for charting. They map between:
//! - **Domain**: The space of your data values (e.g., `0.0` to `100.0`)
//! - **Normalized**: A standard `[0.0, 1.0]` range for consistent transformations
//!
//! # Scale Types
//!
//! - [`Linear`] - For linearly distributed data (most common)
//! - [`Logarithmic`] - For exponentially distributed data (e.g., scientific data)
//!
//! # The Scale Trait
//!
//! The [`Scale`] trait defines the interface all scales must implement:
//!
//! - `normalize` / `denormalize` - Convert between domain and normalized space
//! - `pan` / `zoom` - Modify the visible domain
//! - `tick_iter` / `ticks` - Generate axis tick marks
//! - `extend_domain` - Expand domain to include new data
//! - `is_valid_domain_value` - Check if a value is valid for this scale
//!
//! # Generic Types
//!
//! Scales are generic over two types:
//! - `Domain` (D) - The type of your data values (typically `f32` or `f64`)
//! - `Normalized` (N) - The type for the normalized range (typically `f32` or `f64`)
//!
//! This allows mixing precision levels (e.g., `f64` domain with `f32` normalized values).
//!
//! # Examples
//!
//! ## Creating and Using a Linear Scale
//!
//! ```rust
//! use tjart::{Scale, scale::Linear};
//!
//! // Create a scale for data ranging from 0 to 100
//! let scale = Linear::<f64, f64>::new(0.0, 100.0);
//!
//! // Map data values to [0.0, 1.0]
//! assert_eq!(scale.normalize(&0.0), 0.0);
//! assert_eq!(scale.normalize(&50.0), 0.5);
//! assert_eq!(scale.normalize(&100.0), 1.0);
//!
//! // Map normalized values back to data
//! assert_eq!(scale.denormalize(0.25), 25.0);
//! ```
//!
//! ## Creating a Logarithmic Scale
//!
//! ```rust
//! use tjart::{Scale, scale::Logarithmic};
//!
//! // Base 10 logarithmic scale from 1 to 1000
//! let scale = Logarithmic::<f64, f64>::new(10.0, 1.0, 1000.0);
//!
//! // Values are distributed logarithmically
//! let norm_10 = scale.normalize(&10.0);
//! let norm_100 = scale.normalize(&100.0);
//!
//! // These are equally spaced in normalized space
//! assert!((norm_10 - 0.333).abs() < 0.01);
//! assert!((norm_100 - 0.666).abs() < 0.01);
//! ```
//!
//! ## Panning and Zooming
//!
//! ```rust
//! use tjart::{Scale, scale::Linear};
//!
//! let mut scale = Linear::<f64, f64>::new(0.0, 100.0);
//!
//! // Pan: shift the view by a normalized amount
//! scale.pan(0.1); // Shift by 10% of range (10 units)
//! assert_eq!(scale.domain(), (&10.0, &110.0));
//!
//! // Zoom: change the visible range
//! let mut scale = Linear::<f64, f64>::new(0.0, 100.0);
//! scale.zoom(2.0, Some(0.5)); // 2x zoom at center
//! assert_eq!(scale.domain(), (&25.0, &75.0));
//! ```
//!
//! ## Generating Ticks for Axes
//!
//! ```rust
//! use tjart::{Scale, scale::Linear};
//!
//! let scale = Linear::<f64, f64>::new(0.0, 100.0);
//!
//! // Generate ticks for axis labels
//! for tick in scale.tick_iter() {
//!     match tick.level {
//!         0 => println!("Major tick: {}", tick.value),
//!         1 => println!("Minor tick: {}", tick.value),
//!         _ => {}
//!     }
//! }
//! ```
//!
//! ## Reversed Scales
//!
//! ```rust
//! use tjart::{Scale, scale::Linear};
//!
//! // Reversed scale: max < min
//! let scale = Linear::<f64, f64>::new(100.0, 0.0);
//!
//! // Normalization is reversed
//! assert_eq!(scale.normalize(&100.0), 0.0);
//! assert_eq!(scale.normalize(&0.0), 1.0);
//! ```

mod linear;
mod log;
mod tick_iter;

/// Utilities
pub mod util;

pub use linear::Linear;
pub use log::Logarithmic;
pub use tick_iter::TickIter;

/// Represents a tick mark on an axis.
///
/// Ticks are generated by scales to indicate where labels and grid lines
/// should be drawn on chart axes.
///
/// # Fields
///
/// - `value`: The position of the tick in domain space
/// - `level`: The importance level (0 = major tick, 1 = minor tick, etc.)
///
/// # Examples
///
/// ```rust
/// use tjart::{Scale, scale::{Linear, Tick}};
///
/// let scale = Linear::<f64, f64>::new(0.0, 100.0);
/// let ticks: Vec<Tick<f64>> = scale.ticks();
///
/// // Filter for major ticks only
/// let major_ticks: Vec<_> = ticks.iter()
///     .filter(|t| t.level == 0)
///     .collect();
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Tick<T> {
    /// The position of this tick in domain space.
    pub value: T,
    /// The importance level (0 = major, 1 = minor, higher = less important).
    pub level: u8,
}

/// Trait for mapping between a data domain and a normalized [0, 1] range.
///
/// Scales are the core abstraction for coordinate mapping in charting.
/// They handle the mathematics of converting data values to normalized
/// positions that can then be mapped to screen coordinates.
///
/// # Type Parameters
///
/// - `Domain`: The type of data values (e.g., `f64`, `f32`)
/// - `Normalized`: The type for normalized [0, 1] values (e.g., `f32`)
///
/// # Implementations
///
/// The library provides two built-in scale types:
/// - [`Linear`] - For linearly distributed data
/// - [`Logarithmic`] - For logarithmically distributed data
///
/// # Out-of-Range Values
///
/// The `normalize` methods intentionally do not clamp values to [0, 1].
/// Values outside the domain will map to values outside [0, 1],
/// allowing the renderer to decide how to handle them (clip, extend, etc.).
///
/// # Examples
///
/// ```rust
/// use tjart::{Scale, scale::Linear};
///
/// let mut scale = Linear::<f64, f64>::new(0.0, 100.0);
///
/// // Basic normalization
/// assert_eq!(scale.normalize(&50.0), 0.5);
///
/// // Out-of-range values are not clamped
/// assert_eq!(scale.normalize(&150.0), 1.5);
/// assert_eq!(scale.normalize(&-50.0), -0.5);
///
/// // Modify the domain
/// scale.set_domain(0.0, 200.0);
/// assert_eq!(scale.normalize(&100.0), 0.5);
/// ```
pub trait Scale {
    /// The type of values in the data domain (e.g., `f64`, `f32`).
    type Domain;
    /// The type for normalized `[0, 1]` values (e.g., `f32`, `f64`).
    type Normalized;

    /// Returns the current data domain as `(min, max)`.
    fn domain(&self) -> (&Self::Domain, &Self::Domain);

    /// Sets the data domain to the given `min` and `max` values.
    fn set_domain(&mut self, min: Self::Domain, max: Self::Domain);

    /// Map a domain value into normalized [0.0, 1.0].
    /// Returns None if numeric conversion fails.
    fn normalize_opt(&self, value: &Self::Domain) -> Option<Self::Normalized>;

    /// Map a domain value into normalized [0.0, 1.0].
    /// Panics if numeric conversion fails.
    fn normalize(&self, value: &Self::Domain) -> Self::Normalized {
        self.normalize_opt(value).unwrap()
    }

    /// Map a normalized position [0.0, 1.0] back into domain.
    /// Returns None if numeric conversion fails.
    fn denormalize_opt(&self, t: Self::Normalized) -> Option<Self::Domain>;

    /// Map a normalized position [0.0, 1.0] back into domain.
    /// Panics if numeric conversion fails.
    fn denormalize(&self, t: Self::Normalized) -> Self::Domain {
        self.denormalize_opt(t).unwrap()
    }

    /// Pan the domain based on a normalized shift.
    /// Returns None if numeric conversion fails.
    ///
    /// Example: delta_norm = 0.1 shifts the domain by 10% of its length.
    fn pan_opt(&mut self, delta_norm: Self::Normalized) -> Option<()>;

    /// Pan the domain based on a normalized shift.
    /// Panics if numeric conversion fails.
    ///
    /// Example: delta_norm = 0.1 shifts the domain by 10% of its length.
    fn pan(&mut self, delta_norm: Self::Normalized) {
        self.pan_opt(delta_norm).unwrap()
    }

    /// Zoom around an optional normalized anchor.
    /// Returns None if numeric conversion fails.
    ///
    /// factor > 1.0 => zoom in, factor < 1.0 => zoom out.
    /// If `anchor_norm` is None, use center (0.5).
    fn zoom_opt(
        &mut self,
        factor: Self::Normalized,
        anchor_norm: Option<Self::Normalized>,
    ) -> Option<()>;

    /// Zoom around an optional normalized anchor.
    /// Panics if numeric conversion fails.
    ///
    /// factor > 1.0 => zoom in, factor < 1.0 => zoom out.
    /// If `anchor_norm` is None, use center (0.5).
    fn zoom(&mut self, factor: Self::Normalized, anchor_norm: Option<Self::Normalized>) {
        self.zoom_opt(factor, anchor_norm).unwrap()
    }

    /// Lazily generate multi-level ticks in domain space.
    fn tick_iter(&self) -> TickIter<Self::Domain>;

    /// Collect ticks into a Vec. Prefer [`Scale::tick_iter`] when you only need to stream ticks.
    fn ticks(&self) -> Vec<Tick<Self::Domain>> {
        self.tick_iter().collect()
    }

    /// Extend domain so that [other_min, other_max] fits inside.
    fn extend_domain(&mut self, other_min: &Self::Domain, other_max: &Self::Domain);

    /// Whether this value is allowed for this scale.
    fn is_valid_domain_value(&self, value: &Self::Domain) -> bool;
}
